# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions

name: ðŸ”„ CI/CD

on:
  push:
    branches: ["main", "beta", "*.*.*"]
  pull_request:
    branches: ["main", "beta", "*.*.*"]

  workflow_dispatch: # allow manual trigger

  # Used by the GitHub merge queue feature.
  # Documentation: https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue
  merge_group:

env:
  NAMESPACE_NAME: "freegamescatcher"
  IMAGE_NAME: "freegamescatcher-core"

jobs:
  build:
    name: âš™ï¸ Build

    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v3

      - name: ðŸŒ Use Node.js LTS
        uses: actions/setup-node@v3
        with:
          node-version: lts/*

      - name: ðŸ—‚ Cache "node_modules"
        uses: actions/cache@v3
        id: yarn-cache # use this to check for `cache-hit` (`steps.yarn-cache.outputs.cache-hit != 'true'`)
        with:
          path: "**/node_modules"
          key: ${{ runner.arch }}-${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.arch }}-${{ runner.os }}-yarn-

      - name: ðŸ“¦ Install dependencies
        if: steps.yarn-cache.outputs.cache-hit != 'true'
        run: yarn install --frozen-lockfile

      - name: âš™ï¸ Build application
        run: yarn run build

      - name: ðŸ—ƒ List the state of node modules
        if: steps.yarn-cache.outputs.cache-hit != 'true'
        continue-on-error: true
        run: yarn list

  test-unit:
    name: ðŸ§ª Unit tests

    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v3

      - name: ðŸŒ Use Node.js LTS
        uses: actions/setup-node@v3
        with:
          node-version: lts/*

      - name: ðŸ—‚ Cache "node_modules"
        uses: actions/cache@v3
        id: yarn-cache # use this to check for `cache-hit` (`steps.yarn-cache.outputs.cache-hit != 'true'`)
        with:
          path: "**/node_modules"
          key: ${{ runner.arch }}-${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.arch }}-${{ runner.os }}-yarn-

      - name: ðŸ“¦ Install dependencies
        if: steps.yarn-cache.outputs.cache-hit != 'true'
        run: yarn install --frozen-lockfile

      - name: ðŸ§ª Run unit tests
        run: yarn run test:unit

      - name: ðŸ—ƒ List the state of node modules
        if: steps.yarn-cache.outputs.cache-hit != 'true'
        continue-on-error: true
        run: yarn list

  release:
    name: ðŸ”– Release

    runs-on: ubuntu-latest

    needs: [build, test-unit]

    # Skip this job if the event is a merge_group or if the actor is dependabot.
    if: github.event_name != 'merge_group' || github.actor != 'dependabot[bot]'

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v3
        with:
          # used by semantic-release to bypass the branch protection rules
          token: ${{ secrets.GH_TOKEN }}

      - name: ðŸŒ Use Node.js LTS
        uses: actions/setup-node@v3
        with:
          node-version: lts/*

      - name: ðŸ—‚ Cache "node_modules"
        uses: actions/cache@v3
        with:
          path: "**/node_modules"
          key: ${{ runner.arch }}-${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.arch }}-${{ runner.os }}-yarn-

      - name: ðŸ”– Release application
        run: yarn run release
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
          # NPM_TOKEN: ${{ secrets.NPM_TOKEN }} # optional, needed to publish packages on npm
        id: version # save the version to use in an other step/job
    outputs:
      version: ${{ steps.version.outputs.nextVersion }}

  push:
    name: ðŸ³ Build and push image

    runs-on: ubuntu-latest

    needs: release

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v3

      - name: ðŸŒ³ Extract branch name
        id: branch_name
        shell: bash
        run: |
          git_ref=$(echo ${{ github.ref }} | cut -d'/' -f 3)
          default_branch=${{ github.event.repository.default_branch }}
          head_ref=${{ github.head_ref }}

          echo Git reference: $git_ref
          echo Default branch: $default_branch
          echo Head ref: $head_ref

          if [ -z $head_ref ]; then
              echo "No head reference branch name found, so using git reference name as [$git_ref]"
              branch_name=$git_ref
          else
              echo "Head reference branch name found, using it as [$head_ref]"
              branch_name=$head_ref
          fi

          # replace all '/' with '-'
          branch_name_sanitized=${branch_name//\//-}

          if [ "$branch_name_sanitized" = "$default_branch" ]; then
              echo "Branch name [$branch_name_sanitized] is the default repository branch name [$default_branch], so using 'latest' as branch_name_sanitized"
              branch_name_sanitized="latest"
          fi

          echo Extract branch name used: $branch_name_sanitized
          echo value=$branch_name_sanitized >> $GITHUB_OUTPUT

      - name: âš™ï¸ Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: ðŸ›  Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: ðŸ“² Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: ðŸ³ Build and push image [${{ steps.branch_name.outputs.value }}]
        uses: docker/build-push-action@v3
        with:
          context: . # https://github.com/marketplace/actions/build-and-push-docker-images#git-context
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.branch_name.outputs.value }}
          build-args: |
            NODE_ENV=pre-production
            VERSION=${{ steps.branch_name.outputs.value }}

      - name: ðŸ³ Build and push image [${{ needs.release.outputs.version }}]
        uses: docker/build-push-action@v3
        if: needs.release.outputs.version # deploy only if there is a new published version
        with:
          context: . # https://github.com/marketplace/actions/build-and-push-docker-images#git-context
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ needs.release.outputs.version }}
          build-args: |
            VERSION=${{ needs.release.outputs.version }}

    outputs:
      branch_name: ${{ steps.branch_name.outputs.value }}

  deploy:
    name: ðŸš€ Deploy

    runs-on: ubuntu-latest

    needs: [release, push]

    strategy:
      fail-fast: false
      matrix:
        environment: [pre-production, production]
        deployment-suffix: [prep, prod]
        ready-for-production: ["${{ github.event_name != 'pull_request' && needs.release.outputs.version }}"]
        exclude:
          - environment: production
            ready-for-production: false

          - environment: pre-production
            deployment-suffix: prod
          - environment: production
            deployment-suffix: prep

    environment: ${{ matrix.environment }} # refer to https://github.com/size-up/freegamescatcher-core/settings/environments
    concurrency: ${{ matrix.environment }} # refer to https://docs.github.com/en/actions/using-jobs/using-concurrency

    steps:
      - name: âš™ï¸ Set up kubectl
        uses: tale/kubectl-action@v1
        with:
          base64-kube-config: ${{ secrets.OCI_KUBE_CONFIG }}

      - name: ðŸ”Š Display deployments before update
        run: kubectl get deployments -n ${{ env.NAMESPACE_NAME }} ${{ env.IMAGE_NAME }}-${{ matrix.deployment-suffix }} -o=wide

      - name: ðŸš€ Set image [${{ needs.push.outputs.branch_name }}] to pre-production
        if: matrix.environment == 'pre-production'
        id: image_updated
        run: |
          echo value=$(kubectl set image -n ${{ env.NAMESPACE_NAME }} deployment/${{ env.IMAGE_NAME }}-prep ${{ env.IMAGE_NAME }}-prep=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ needs.push.outputs.branch_name }}) >> $GITHUB_OUTPUT

      - name: ðŸ”Š Display "set_image" step output
        if: matrix.environment == 'pre-production'
        run: echo ${{ steps.image_updated.outputs.value }}

      # Rollout the deployment only if the image hasn't been updated, to avoid unnecessary restarts.
      - name: ðŸš€ Rollout pre-production deployment
        id: rollout
        if: matrix.environment == 'pre-production' && steps.image_updated.outputs.value == '' # rollout only if the image hasn't been updated
        run: echo value=$(kubectl rollout -n ${{ env.NAMESPACE_NAME }} restart deployment ${{ env.IMAGE_NAME }}-prep) >> $GITHUB_OUTPUT

      - name: ðŸ”Š Display "rollout" step output
        if: matrix.environment == 'pre-production' && steps.rollout.outputs.value
        run: echo ${{ steps.rollout.outputs.value }}

      - name: ðŸš€ Deploy to production [v${{ needs.release.outputs.version }}]
        if: matrix.environment == 'production'
        run: kubectl set image -n ${{ env.NAMESPACE_NAME }} deployment/${{ env.IMAGE_NAME }}-prod ${{ env.IMAGE_NAME }}-prod=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ needs.release.outputs.version }}

      - name: ðŸ”Š Display deployments after update
        run: kubectl get deployments -n ${{ env.NAMESPACE_NAME }} ${{ env.IMAGE_NAME }}-${{ matrix.deployment-suffix }} -o=wide
